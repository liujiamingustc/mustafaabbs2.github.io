<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.7">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-07-06T13:21:33+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Programming with Fluids</title><subtitle>I write about topics in numerical mathematics and Computational Fluid Dynamics (CFD). There are some colorful pictures too</subtitle><author><name>Mustafa Bhotvawala</name></author><entry><title type="html">Setting up a Fluid Structure Interaction Workflow with OpenFOAM and deal.II</title><link href="http://localhost:4000/ofFSI/" rel="alternate" type="text/html" title="Setting up a Fluid Structure Interaction Workflow with OpenFOAM and deal.II" /><published>2020-06-27T00:00:00+03:00</published><updated>2020-06-27T00:00:00+03:00</updated><id>http://localhost:4000/ofFSI</id><content type="html" xml:base="http://localhost:4000/ofFSI/">&lt;p&gt;I spent a summer with a research group specializing in a variety of topics in non-linear dynamics, one of them being the Fluid Structure Interaction (FSI) of flapping wings. It was 2015 — I did not work with OpenFOAM then, but I’m sure the more recent FSI solvers with foam-extend were only in their infancy, in terms of popularity.&lt;/p&gt;

&lt;p&gt;foam-extend is getting a bit older for wear in 2020. Other development branches, including the ESI-OpenCFD (v1912 etc) that we’ve made use of on our WSL Ubuntu in previous articles may not be fully compatible with the other FSI utilities out there, including &lt;a href=&quot;https://github.com/davidsblom/FOAM-FSI&quot;&gt;FOAM-FSI&lt;/a&gt; (Feel free to correct me on this though).&lt;/p&gt;

&lt;p&gt;I’m going to keep it short and get to the workflow. I want users to be able to set up a common FSI tutorial case — a perpendicular flap in a 2-D channel. There are a multitude of options — especially with the choice of a FE solver, I hope this helps you avoid a very tedious path to just setting up an environment. I had to personally go through a ton of debugging to set this up correctly — this should help everyone save some time.&lt;/p&gt;

&lt;p&gt;How are forces transmitted back and forth between fluid and solid solvers? Here’s where &lt;a href=&quot;https://www.precice.org/&quot;&gt;preCICE&lt;/a&gt; comes in. PreCICE can couple different types of solvers together in a multi-physics environment. For example, an **adapter **communicates data from the fluid solver, which is then mapped via PreCICE and lands at the adapter of the solid solver, and then the other way around. There are adapters for a range of different solvers, which to me, gives PreCICE its appeal.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2220/1*2jlsdJ8fMwGRKVz2qHBQvw.png&quot; alt=&quot;(taken from precice.org)&quot; /&gt;
&lt;em&gt;(taken from precice.org)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You need &lt;strong&gt;five&lt;/strong&gt; things:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;preCICE&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A fluid solver — OpenFOAM (I use v19.12)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An OpenFOAM-preCICE adapter&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A solid solver — deal.II&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A deal.II-preCICE adapter&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are some dependencies I recommend you have before you start. These are the ones I needed for &lt;strong&gt;Ubuntu-18.04&lt;/strong&gt;. Copy and paste the following in your terminal.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt update &amp;amp;&amp;amp; \
sudo apt install build-essential cmake libeigen3-dev libxml2-dev libboost-all-dev python3-dev python3-numpy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As a note to organize your files better, create a directory titled FSI in your home folder that will house all the source code in the coming section. I’m going to assume you have a working OpenFOAM installation on your system. If not, check this out.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A. Get preCICE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I prefer having the source and building with CMake. Follow the instructions in this &lt;a href=&quot;https://github.com/precice/precice/wiki/Building:-Using-CMake&quot;&gt;wiki&lt;/a&gt;. For people still drawing a blank, cmake generates your MakeFile on which you run the command make for the actual compilation. make install sends the installed files to their intended locations on the system.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B&lt;/strong&gt;. &lt;strong&gt;Get the OpenFOAM adapter for preCICE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is explained &lt;a href=&quot;https://github.com/precice/openfoam-adapter/wiki/Building&quot;&gt;here&lt;/a&gt;. You will use the Allwmake script to create the adapter -which is actually just a shared library preciceAdapterFunctionObject , which needs to be referenced in &lt;em&gt;controlDict&lt;/em&gt;. Don’t worry about this, the repository is equipped with working tutorials where you don’t need to change a thing!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C. Get deal.II&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is the solid solver we’ll use. Just like preCICE, the installation is again done from source — you’ll have to &lt;a href=&quot;https://www.dealii.org/9.2.0/readme.html&quot;&gt;download the source code&lt;/a&gt; and compile it. This takes a while — allot a few hours for a compilation when done with a single processor.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note —&lt;/strong&gt; I found it difficult to install deal.II with the OpenFOAM environment sourced because of clashing dependencies. Be sure to comment out sourcing the OpenFOAM .bashrc file in your system .bashrc.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;D&lt;/strong&gt;. &lt;strong&gt;Get the deal.II adapter for preCICE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Follow the instructions on this &lt;a href=&quot;https://github.com/precice/dealii-adapter/wiki/Building&quot;&gt;page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ideally, you should now have a folder with the source code for &lt;strong&gt;A&lt;/strong&gt;, &lt;strong&gt;B&lt;/strong&gt;, &lt;strong&gt;C&lt;/strong&gt;, and &lt;strong&gt;D&lt;/strong&gt;. &lt;strong&gt;Keep the source code around&lt;/strong&gt; — we may need to modify and recompile.&lt;/p&gt;

&lt;p&gt;Now — download the &lt;a href=&quot;https://github.com/precice/tutorials/tree/master/FSI&quot;&gt;tutorials repository&lt;/a&gt; in your &lt;strong&gt;$FOAM_RUN&lt;/strong&gt; folder. These are the FSI cases we can test our environment with.&lt;/p&gt;

&lt;p&gt;The tutorial we will test is the FSI/flap_perp_2D/OpenFOAM-deal.II in the tutorials folder.&lt;/p&gt;

&lt;p&gt;Navigate to the &lt;strong&gt;deal.II adapter (D)&lt;/strong&gt; source folder. The adapter has individual solvers which you can build with cmake and make . Do this in the linear_elasticity/ subfolder. Copy the executable you get to the FSI/flap_perp_2D/OpenFOAM-deal.II/Solid folder. This is your solid solver executable.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Open two terminals&lt;/strong&gt; — source one with OpenFOAM, leave the other one unsourced. On the unsourced terminal, after navigating to FSI/flap_perp_2D/OpenFOAM-deal.II/, run ./Solid/linear_elasticity Solid/linear_elasticity.prm . This starts the solid solver — preCICE will now wait for you to execute OpenFOAM on the other terminal:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*ub-3jvm69WLyHUTRvTNAeg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Go to the terminal sourced with OpenFOAM. Run the runFluid script to launch the OpenFOAM run script. &lt;strong&gt;This will start the solver on both terminals.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It is important that you proof *controlDict *to make sure your fluid and solid results are being printed at the same time intervals. You will now have VTK folders in both Solid/ and Fluid/ folders which can be read into Paraview.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/4496/1*KqOszeSytheCB3K_edX_oQ.png&quot; alt=&quot;Results from Fluid/ (time =5)&quot; /&gt;&lt;em&gt;Results from Fluid/ (time =5)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/4496/1*thAE8HLpblpmyKsZ9g8PYg.png&quot; alt=&quot;Results from Solid/ (time =5)&quot; /&gt;&lt;em&gt;Results from Solid/ (time =5)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is a &lt;strong&gt;dynamicMesh&lt;/strong&gt; being employed. You can observe the changes in the structure with each time step. For instance, the meshes at the first and last time step look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/4496/1*FGktko4MWLVJuBQmUn4_tw.png&quot; alt=&quot;Channel at time = 0&quot; /&gt;&lt;em&gt;Channel at time = 0&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/4496/1*DFcOz8fgv48HF1k7wFsPag.png&quot; alt=&quot;Channel at time =5&quot; /&gt;&lt;em&gt;Channel at time =5&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This could be a good point for more complicated simulations. I’m no expert on deal.II, but there are other models, including non-linear elasticity that can be employed. 3-D cases, including the possibility of preparing cases for flapping airfoils — if you have other ideas on simple use cases in FSI, write to me!&lt;/p&gt;</content><author><name>Mustafa Bhotvawala</name></author><summary type="html">I spent a summer with a research group specializing in a variety of topics in non-linear dynamics, one of them being the Fluid Structure Interaction (FSI) of flapping wings. It was 2015 — I did not work with OpenFOAM then, but I’m sure the more recent FSI solvers with foam-extend were only in their infancy, in terms of popularity.</summary></entry><entry><title type="html">Analyzing SIMPLEC — the “consistent” simpleFOAM control</title><link href="http://localhost:4000/ofConsistent/" rel="alternate" type="text/html" title="Analyzing SIMPLEC — the “consistent” simpleFOAM control" /><published>2020-06-24T00:00:00+03:00</published><updated>2020-06-24T00:00:00+03:00</updated><id>http://localhost:4000/ofConsistent</id><content type="html" xml:base="http://localhost:4000/ofConsistent/">&lt;p&gt;The previous articles in this series took on debugging the simpleFoam solver through a VSCode debugger. SIMPLEC, a “consistent” implementation of the SIMPLE algorithm can be toggled on and off via the “consistent” switch in your fvSolutions file.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*U_rByI0s4seJJbA9Ja7Jsg.png&quot; alt=&quot;system/fvSolution&quot; /&gt;&lt;em&gt;system/fvSolution&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The theory on SIMPLEC is a bit dense — so let’s go through it here.&lt;/p&gt;

&lt;p&gt;When we derived our starting decomposed equation for SIMPLE:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*KSeNYZ5kgGW7ioLy0wAFrQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Just as a reminder — A has the diagonal coefficients of velocity U, while H has the non-diagonal coefficients.&lt;/p&gt;

&lt;p&gt;The SIMPLE algorithm works on velocity and pressure corrections in an iterative method. Quantities like U&lt;em&gt;, p&lt;/em&gt; are the predicted value in the first iteration of a loop, and U&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;, p&lt;/code&gt; are the correction quantities that are used to correct the predicted values.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*OUqCGhkTpel7pPP_4uGlFw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A key assumption in the SIMPLE algorithm is that H(U`) = 0 — which means that all the non diagonal coefficients of the correction velocity are 0. This correction velocity is obtained from the Poisson equation for pressure.&lt;/p&gt;

&lt;p&gt;This means that the contributions to the correction velocity from all neighbouring cells are dropped.&lt;/p&gt;

&lt;p&gt;For &lt;strong&gt;SIMPLE&lt;/strong&gt;, the correction velocity equation is derived as:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*x8pK1OXExDe9-mhzf5ORSg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The pressure correction term can be large and needs to be under-relaxed with each step for this reason. So the algorithm then ends up doing a step like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*Z4mkRRhyCD_dYPtDk_vUSA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;where α is the under-relaxation factor. This means that the pressure correction step is happening much slower than technically possible. How do we get rid of this? By using a consistent formulation: &lt;strong&gt;SIMPLEC&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SIMPLEC has the same basic formulation for correction velocity:&lt;/p&gt;

&lt;p&gt;AU&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; = H1(U&lt;/code&gt;)-∇ p`&lt;/p&gt;

&lt;p&gt;Here, we are &lt;strong&gt;not&lt;/strong&gt; going to ignore the neighbour velocities (the off-diagonal terms). Let’s rename H(U&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;) as H1(U&lt;/code&gt;) to avoid confusion with H(U*).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*X7D_82eoEtpktqMkgygwEw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Where At = A — H1. Deriving further&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*qxkszzkOCQ1A5lh7izeZpQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Compare this to the SIMPLE momentum corrector step to find U:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*_rt4hXktIbewk4jebtxblw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can see that the velocity is corrected by an equivalent of:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*_xYOcHyf18tfd_1X6Sr7jg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;How does this look like in OpenFOAM?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*16jQ5RMrVrAw2VqmldZG6Q.png&quot; alt=&quot;SIMPLEC&quot; /&gt;&lt;em&gt;SIMPLEC&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is represented by the term (rAU-rAtU())*fvc::grad(p). That’s the correction term for SIMPLEC! Observe the code to see if this matches with theory.&lt;/p&gt;

&lt;p&gt;The velocity is then calculated by using the corrected HbyA. It’s that simple! There are no extra equations to be solved (like other SIMPLE variants like SIMPLER), and this may give you gains of 20–30% due to no under-relaxation being required. If you use this article to do a comparison between convergence in SIMPLE and SIMPLEC, do let me know how they fare against each other.&lt;/p&gt;</content><author><name>Mustafa Bhotvawala</name></author><summary type="html">The previous articles in this series took on debugging the simpleFoam solver through a VSCode debugger. SIMPLEC, a “consistent” implementation of the SIMPLE algorithm can be toggled on and off via the “consistent” switch in your fvSolutions file.</summary></entry><entry><title type="html">Stepping through simpleFoam with VS Code — a guide to debugging solvers</title><link href="http://localhost:4000/of2/" rel="alternate" type="text/html" title="Stepping through simpleFoam with VS Code — a guide to debugging solvers" /><published>2020-06-20T00:00:00+03:00</published><updated>2020-06-20T00:00:00+03:00</updated><id>http://localhost:4000/of2</id><content type="html" xml:base="http://localhost:4000/of2/">&lt;p&gt;This is a the second article in a series exploring utilities of OpenFOAM for viewers beginning with CFD — geared towards OpenFOAM beginners. The toolbox has a steep learning curve, but a see-through box offers far more control than a black one. Though we set up an environment to code our own solvers in the last article, we don’t have a debug environment to fix things when wrong, or to see how the code flows.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.google.com/search?q=Openfoam+debug+Opt&amp;amp;rlz=1C1CHBF_enKW850KW850&amp;amp;oq=Openfoam+debug+Opt&amp;amp;aqs=chrome..69i57j35i39l3j69i60j69i58j69i60l2.4077j0j7&amp;amp;sourceid=chrome&amp;amp;ie=UTF-8&quot;&gt;Debug mode&lt;/a&gt; allows you to do just this. We unpacked OpenFOAM directly into the &lt;em&gt;/opt/&lt;/em&gt; folder in our last article. This was the default “Opt” compilation. OpenFOAM needs to be compiled again in debug mode. Navigate to your .bashrc file in OpenFOAM’s* etc/* folder and switch the flag:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;WM_COMPILE_OPTION=**Debug**
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Move back a directory and compile OpenFOAM:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./Allwmake
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Debug mode is almost double the size of the normal compilation. This will take a while, atleast a few hours. Try running *Allwmake *in parallel to speed things up (for example, here with four processors):&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./Allwmake -j 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I recommend aliases to switch between your debug and Opt modes. Copy your OpenFOAM &lt;em&gt;.bashrc *file into&lt;/em&gt; .bashrc_debug*. Source your *.bashrc_debug *file to activate debug mode.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;**alias** of1912deb=”source /opt/OpenFOAM/OpenFOAM-v1912/etc/bashrc_debug”
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A quick check to see if you’re in debug mode -&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;**which** icoFoam

//should get--&amp;gt; /opt/OpenFOAM/OpenFOAM-v1912/platforms/linux64Gcc63DPInt32**Debug**/bin/icoFoam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Debug mode allows the &lt;a href=&quot;http://www.gnu.org/software/gdb/&quot;&gt;gdb&lt;/a&gt; debugger to step through your code. You could do this in a terminal too, but I prefer working in an IDE, especially for code that’s as layered as OpenFOAM.&lt;/p&gt;

&lt;p&gt;We’ll walk through&lt;a href=&quot;https://www.openfoam.com/documentation/guides/latest/doc/guide-applications-solvers-incompressible-simpleFoam.html&quot;&gt; simpleFoam&lt;/a&gt; in this example. simpleFoam uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/SIMPLE_algorithm&quot;&gt;SIMPLE&lt;/a&gt; algorithm to solve the N-S equations for incompressible fluid flow, for a steady state solution. It’s a great starting point for most explanation on OpenFOAM.&lt;/p&gt;

&lt;p&gt;Copy simpleFoam into your $WM_PROJECT_USER_DIR.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp -r $FOAM_SOLVERS/incompressible/simpleFoam $WM_PROJECT_USER_DIR
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To debug the solver, you need to supply it with the input files it needs from the OpenFOAM case structure. I simply copy a &lt;em&gt;pitzDaily&lt;/em&gt; tutorial into the same folder as the solver code:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp -r $FOAM_SOLVERS/incompressible/simpleFoam/pitzDaily/* $WM_PROJECT_USER_DIR/simpleFoam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The contents of your folder should look like this:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*ir8AASrzIsdDAxqrdqpK9Q.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Start your VSCode environment:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;code .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Navigate to the &lt;em&gt;simpleFoam.C *file. Place two breakpoints at the same locations as in the picture, after *argList:addNote&lt;/em&gt; and at &lt;em&gt;turbulence -&amp;gt; validate()&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*GfL7HeWOzxlwv6gDOJTLAQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For those not familiar with debuggers — find the command Run — Start Debugging to execute.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*liKX-zqCw6G8-ZOjRfb3gg.png&quot; alt=&quot;Options to move along the code — Continue, Step Over, Step Into, Step Out&quot; /&gt;
&lt;em&gt;Options to move along the code — Continue, Step Over, Step Into, Step Out&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To move through the code, there are four options you need to use:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Continue&lt;/strong&gt;: will move to the next breakpoint&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Step Over&lt;/strong&gt;: will proceed to the next line of code without entering the function on that line. If you step over &lt;em&gt;turbulence-&amp;gt;validate()&lt;/em&gt;, it will move to the next line after executing it, but you will not move through the contents of the method itself&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Step Into&lt;/strong&gt;: will enter the method&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Step Out&lt;/strong&gt;: returns control to the preceding stack frame — i.e. if you’ve entered &lt;em&gt;turbulence-&amp;gt;validate()&lt;/em&gt; with Step Into, it will finish execution of the method and return control to simpleFoam.C&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s run the debugger. If you want to work your way through the following header files too, I recommend adding a breakpoint at the *argList::addNote *line.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;argList::addNote

(

&quot;Steady-state solver for incompressible, turbulent flows.&quot;

);

#include &quot;postProcess.H&quot;
#include &quot;addCheckCaseOptions.H&quot;
#include &quot;setRootCaseLists.H&quot;
#include &quot;createTime.H&quot;
#include &quot;createMesh.H&quot;
#include &quot;createControl.H&quot;
#include &quot;createFields.H&quot;
#include &quot;initContinuityErrs.H&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We won’t enter the header files this way, but I can quickly desribe how the flow of code happens through these.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;postProcess.H&quot;
#include &quot;addCheckCaseOptions.H&quot;
#include &quot;setRootCaseLists.H&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;em&gt;postProcess.H&lt;/em&gt; header file checks if the postProcess flag is issued and creates a list of all the function objects in the controlDict. *setRootCaseLists.H *parses through all the advanced switches that can be given to simpleFoam. For a list of these switches, see the &lt;a href=&quot;https://www.openfoam.com/documentation/guides/latest/man/simpleFoam.html&quot;&gt;documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Header files are entered as though they’re part of the code. You can observe which file the debugger is currently paused at by looking at the call stack.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*n_GFqwR0A_36kyeoatGqLQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Let’s work our way down the code:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;createTime.H&quot;
#include &quot;createMesh.H&quot;
#include &quot;createControl.H&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;createTime.H&lt;/em&gt; and &lt;em&gt;createMesh.H&lt;/em&gt;, as their names suggests, create their respective* runTime* and &lt;em&gt;mesh&lt;/em&gt; objects. &lt;em&gt;createTime.H&lt;/em&gt; generates your first real output statement to your log file — “Create time”.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Foam::Info&amp;lt;&amp;lt; “Create time\n” &amp;lt;&amp;lt; Foam::endl;

Foam::Time runTime(Foam::Time::controlDictName, args);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;createMesh.H&lt;/em&gt; is simple — it creates a mesh object (class &lt;em&gt;fvMesh&lt;/em&gt;) for the corresponding &lt;em&gt;runTime&lt;/em&gt; object.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Foam::autoPtr&amp;lt;Foam::fvMesh&amp;gt; meshPtr(nullptr);

Foam::fvMesh&amp;amp; mesh = meshPtr();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;createFields.H *is present in your solver directory. The field objects &lt;strong&gt;*p&lt;/strong&gt;&lt;/em&gt; (pressure), &lt;strong&gt;&lt;em&gt;U&lt;/em&gt;&lt;/strong&gt; (velocity) are created here. Moreover, any new fields you want to evaluate — here’s where they need to be created for the solver to parse through.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*zJ46W2L9c0C7XgDPHxRa4A.png&quot; alt=&quot;createFields.H&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;createFields.H&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The face flux &lt;strong&gt;&lt;em&gt;phi&lt;/em&gt;&lt;/strong&gt; is also created here through a header file inside *createFields.H. *Additionally, the &lt;strong&gt;transport model&lt;/strong&gt; (based on your viscosity) as well as the &lt;strong&gt;turbulence model&lt;/strong&gt; objects are created here.&lt;/p&gt;

&lt;p&gt;Keep checking your terminal to see your outputs too — this is a sanity check to see that the flow of output is just like what we’d expect:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*GVTQGg15lCugAW9UOwnuhw.png&quot; alt=&quot;Your terminal&quot; /&gt;&lt;em&gt;Your terminal&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Voila, you’ve got through the setting up of the solver — your mesh, time, and fields, and models are now ready. The next article in the series will stick with this example, but move onto the actual code characteristic to &lt;em&gt;simpleFoam&lt;/em&gt; — with a bit of math to explain how the SIMPLE algorithm is implemented.&lt;/p&gt;</content><author><name>Mustafa Bhotvawala</name></author><summary type="html">This is a the second article in a series exploring utilities of OpenFOAM for viewers beginning with CFD — geared towards OpenFOAM beginners. The toolbox has a steep learning curve, but a see-through box offers far more control than a black one. Though we set up an environment to code our own solvers in the last article, we don’t have a debug environment to fix things when wrong, or to see how the code flows.</summary></entry><entry><title type="html">The simpleFoam implementation — explained</title><link href="http://localhost:4000/of3/" rel="alternate" type="text/html" title="The simpleFoam implementation — explained" /><published>2020-06-20T00:00:00+03:00</published><updated>2020-06-20T00:00:00+03:00</updated><id>http://localhost:4000/of3</id><content type="html" xml:base="http://localhost:4000/of3/">&lt;p&gt;Tip — This is not meant to be a standalone article. It’s much more useful walking along this like a tutorial and not just reading through . So I highly recommend catching up to the point of entry in this article with the previous one.&lt;/p&gt;

&lt;p&gt;Let’s look at the actual implementation of simpleFoam in this article. We left off by preparing the solver with all the mesh, field, and time objects that it would need. This is what you should see:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*2ytEDfp2nkIn0IIDuwToNg.png&quot; alt=&quot;simpleFoam.C&quot; /&gt;&lt;em&gt;simpleFoam.C&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Before you move ahead, I recommend you see this really good &lt;a href=&quot;https://www.youtube.com/watch?v=OOILoJ1zuiw&quot;&gt;video&lt;/a&gt; (Aidan Wimshurst) on an introduction to the algorithm. (If you haven’t checked the whole series out, please do!)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In an incompressible simulation, you have more variables (&lt;strong&gt;&lt;em&gt;u,v,w,p&lt;/em&gt;&lt;/strong&gt;) than equations. The system cannot be solved directly because there is no explicit equation for pressure. That’s why you need an algorithm to do this. As a refresher, the N-S equation is shown in vector form below:&lt;/p&gt;

&lt;p&gt;ρ D&lt;strong&gt;U&lt;/strong&gt;/Dt = -∇ p + ∇ . &lt;strong&gt;τ&lt;/strong&gt; + ρ** g**&lt;/p&gt;

&lt;p&gt;Let’s convert this into the simplest matrix system we can think of, considering the stress term is a function of velocities too:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MU&lt;/strong&gt; = -∇ p …….. (1)&lt;/p&gt;

&lt;p&gt;Here, &lt;strong&gt;&lt;em&gt;M **&lt;/em&gt;is just the coefficient matrix of the velocities. Now, what most algorithms do is convert this sparse matrix **&lt;em&gt;M **&lt;/em&gt;into a diagonal and an off-diagonal matrix. The diagonal matrix is called **&lt;em&gt;A&lt;/em&gt;&lt;/strong&gt; in OpenFOAM, while the off-diagonal one is called &lt;strong&gt;&lt;em&gt;H&lt;/em&gt;&lt;/strong&gt;. This will become clear in a bit once you see the source code. The decomposition is done as follows:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AU&lt;/strong&gt; -&lt;strong&gt;H&lt;/strong&gt; =-∇ p …….. (2)&lt;/p&gt;

&lt;p&gt;What the algorithm does is essentially the following.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It solves directly for velocity U. This is called the momentum predictor step:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;U&lt;/strong&gt; =** H&lt;strong&gt;/&lt;/strong&gt;A** -∇ p/**A **…….. (3)&lt;/p&gt;

&lt;p&gt;Simple yes? Turns out however, this velocity was not giving a constraint of mass conservation. &lt;strong&gt;This velocity satisfies the momentum equations but not the continuity equations.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;∇.&lt;strong&gt;U&lt;/strong&gt; = 0 …….. (4)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;To satisfy this condition, the equation in (3) is inserted in the equation in (4). This yields a Poisonn equation for pressure — this is solved for pressure.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;∇.(∇p/&lt;strong&gt;A&lt;/strong&gt;) = ∇.(&lt;strong&gt;H&lt;/strong&gt;/&lt;strong&gt;A&lt;/strong&gt;)…….. (5)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The pressure correction is used to obtain the correct velocity that satisfies the continuity equation. *But wait, this no longer satisfies the momentum equation now! *This needs to be iterated in a loop until the solution converges.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s observe how this is implemented. The two main solution components of the algorithm lie inside these two files:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include UEqn.H
#include pEqn.H
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s step into* UEqn.H:*&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*-sDyjYOg1IZCYWqEn2n1UA.png&quot; alt=&quot;UEqn.H&quot; /&gt;&lt;em&gt;UEqn.H&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tmp&amp;lt;fvVectorMatrix&amp;gt; tUEqn
(
fvm::div(phi, U)
+ MRF.DDt(U)
+ turbulence-&amp;gt;divDevReff(U)
==
fvOptions(U)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This creates a tUEqn object of type fvVectorMatrix. This is essentially the **MU **system discussed above. This includes contributions from Moving Reference Frame (MRF) and the stress tensor, both functions of velocity and hence part of the matrix.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;solve(UEqn == -fvc::grad(p))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is equivalent to the &lt;strong&gt;MU&lt;/strong&gt; = -∇ p portion of the algorithm. Now, we have a UEqn object that contains the solution of this system of equations.&lt;/p&gt;

&lt;p&gt;The diagonal matrix is extracted by* UEqn.A() &lt;em&gt;and the off-diagonal matrix by *UEqn.H()&lt;/em&gt;. We see this when we enter &lt;em&gt;pEqn.H&lt;/em&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;volScalarField **rAU**(1.0/UEqn.A());

volVectorField **HbyA**(constrainHbyA(rAU*UEqn.H(), U, p));

surfaceScalarField **phiHbyA**(“phiHbyA”, fvc::flux(HbyA));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;rAU&lt;/strong&gt; is simply 1/A,&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HbyA&lt;/strong&gt; is unsurprisingly, H/A&lt;/p&gt;

&lt;p&gt;and &lt;strong&gt;phiHbyA&lt;/strong&gt; is the surfaceScalarField equivalent of HbyA, which is originally a volVectorField.&lt;/p&gt;

&lt;p&gt;The Poisson equation that needs to be solved is &lt;strong&gt;∇.(∇p/A) = ∇.(H/A)&lt;/strong&gt;, which calculates pressure. This is very direct translation into code:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fvScalarMatrix pEqn

(
fvm::laplacian(rAtU(), p) == fvc::div(phiHbyA)
);

pEqn.solve();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The last step of the algorithm is fairly straightforward too. The new pressure values are used to correct the velocity so that it satisfies the continuity equation. This equation — &lt;strong&gt;U&lt;/strong&gt; =** H&lt;strong&gt;/&lt;/strong&gt;A** -∇ p/&lt;strong&gt;A&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;U = HbyA — rAtU()*fvc::grad(p);

U.correctBoundaryConditions();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That’s the end of one SIMPLE iteration. This will continue until convergence. There are a fair number of components this tutorial did not cover — mainly to avoid a tedious long read, relaxation factors, non-orthogonal correction etc to name a few. If this helped you gain some intuition into how essentially the most fundamental solver in OpenFOAM works, these could be covered in more advanced articles.&lt;/p&gt;</content><author><name>Mustafa Bhotvawala</name></author><summary type="html">Tip — This is not meant to be a standalone article. It’s much more useful walking along this like a tutorial and not just reading through . So I highly recommend catching up to the point of entry in this article with the previous one.</summary></entry><entry><title type="html">Setting up my OpenFOAM Development Environment on Windows!</title><link href="http://localhost:4000/of1/" rel="alternate" type="text/html" title="Setting up my OpenFOAM Development Environment on Windows!" /><published>2020-04-25T00:00:00+03:00</published><updated>2020-04-25T00:00:00+03:00</updated><id>http://localhost:4000/of1</id><content type="html" xml:base="http://localhost:4000/of1/">&lt;p&gt;Well, if you’re this far, you’re no stranger to open source fluid simulation software. Or you’ve finally broken free from the binds that commercial CFD software pose — “I’m just going to do it myself”, you say all too confidently as you jostle out of your fifteenth meeting with your software support that month.&lt;/p&gt;

&lt;p&gt;A full Linux development environment is often too intimidating for those just starting to make a switch from commercial tools to OpenFOAM. Windows until recently was, and to some extent still is, a poor solution for numerical computing. &lt;a href=&quot;https://www.pcworld.com/article/230527/ubuntu_linux_day_16_ext4_vs_ntfs.html&quot;&gt;The NTFS file system on Windows is slower than the ext4 for frequent I/O which is a mainstay of computing applications.&lt;/a&gt; There were limited options to those looking to run OpenFOAM on Windows without a dual-boot.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://openfoam.org/download/windows-vm/&quot;&gt;VM install&lt;/a&gt; was the go-to solution, however I found that it significantly slowed my host device.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A native Windows build, &lt;a href=&quot;http://bluecfd.github.io/Core/About/&quot;&gt;blueCFD-Core&lt;/a&gt;, based on a &lt;a href=&quot;https://www.msys2.org/&quot;&gt;MSys2&lt;/a&gt; build platform (built with on a Cygwin layer for the Linux “feel” and MinGw, for compilation on Windows.). The full software stack makes it quite bulky for use.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/wsl/install-win10&quot;&gt;Windows Subsystem for Linux (WSL)&lt;/a&gt;: The original WSL is a GNU environment for Windows without any virtualization, and with a very slow read/write ability to the Windows file system.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;My move to Windows was recent — circumstances around the pandemic made me switch to a new system which I did not want to have a dual boot on. Luckily, we live in times of the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/wsl/wsl2-index&quot;&gt;WSL2&lt;/a&gt;. The new version of the architecture in WSL allows increased file system performance, perations like cmake and git clone can run up to 20x faster — count me in.&lt;/p&gt;

&lt;p&gt;I will not describe setting up the WSL 2 VM in this article. There is a fairly comprehensive install guide &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/wsl/install-win10&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Once you have WSL ready, download the OpenFOAM release (&lt;a href=&quot;https://sourceforge.net/projects/openfoam/files/v1912/OpenFOAM-v1912-windows10.tgz&quot;&gt;here&lt;/a&gt;, 19.12).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Copy the .tgz to your folder of choice.&lt;/p&gt;

    &lt;p&gt;cp -ar /mnt/c/Users/&lt;USER&gt;/Downloads/OpenFOAM-v1912-windows10.tgz .&lt;/USER&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Untar to the /opt folder and change permissions.&lt;/p&gt;

    &lt;p&gt;sudo tar -xvzf  OpenFOAM-v1912-windows10.tgz -C /opt/
 sudo chown -R $USER /opt/OpenFOAM&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Source your .bashrc file!&lt;/p&gt;

    &lt;p&gt;echo “source /opt/OpenFOAM/OpenFOAM-v1912/etc/bashrc” » ~/.bashrc
 source $HOME/.bashrc&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And you’re good to go. Verify your source by running a tutorial case.&lt;/p&gt;

&lt;p&gt;The purpose of this article is to set up a &lt;strong&gt;development&lt;/strong&gt; environment for OpenFOAM — you need to create:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A directory that houses your custom solver and library source code. This is preferably somewhere in your &lt;strong&gt;$WM_PROJECT_DIR&lt;/strong&gt; folder.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Directories for the binaries generated from your custom solver and the .so files generated from your custom library. You’ll need to create a directory that is defined by your variables &lt;strong&gt;$FOAM_USER_APPBIN&lt;/strong&gt; and **$FOAM_USER_LIBBIN **respectively.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is how my custom solver and library directory (as described in 1.) should look like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*_qMiorNX0Qk96gHyHrhEig.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;myReactingParcelFoam is my custom solver modifying reactingParcelFoam, and surfaceFilmModels is where I hold the libraries that the solver depends on.&lt;/p&gt;

&lt;p&gt;Notice the vscode folder? The perfect pair to OpenFOAM programming, as I’ve discovered, is &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code&lt;/a&gt;. You can download this to run on your Windows system. Yes — you run it on Windows and keep the source in your WSL environment. You need to install the &lt;a href=&quot;https://code.visualstudio.com/remote-tutorials/wsl/getting-started&quot;&gt;remote WSL extension&lt;/a&gt; in VS Code to couple the two environments. Additionally, install the &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools&quot;&gt;C/C++ extension&lt;/a&gt; too.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*9k6bv6VmYFTM0VniBTynMQ.png&quot; alt=&quot;What your extensions should look like&quot; /&gt;&lt;em&gt;What your extensions should look like&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Voila! All you need to do is run the following command in the directory you want to create a VS Code directory for:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;code . 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This creates a .vscode folder in that directory. Additionally, it will open up VS Code with your project, for instance:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*jFosjbe2Wxj2Hqj0XUVMNg.png&quot; alt=&quot;What your VS Code instance should look like (minus the files in .vscode, we’ll get to this)&quot; /&gt;&lt;em&gt;What your VS Code instance should look like (minus the files in .vscode, we’ll get to this)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The files in .vscode that are of relevance are: &lt;em&gt;launch.json&lt;/em&gt;, &lt;em&gt;tasks.json *and *c_cpp_properties.json&lt;/em&gt;. These will be created when you add a configuration, but you will have to modify them. These give VS Code inputs on what task to run.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*wXqMwzDj5VuMw5JV8igGqQ.png&quot; alt=&quot;A sample tasks.json file&quot; /&gt;&lt;em&gt;A sample tasks.json file&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*HJZ4TXPlKAzGRgzHYAZhfA.png&quot; alt=&quot;A sample launch.json file&quot; /&gt;&lt;em&gt;A sample launch.json file&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If you’ve gone through these .json files, the command in &lt;em&gt;tasks.json&lt;/em&gt; is &lt;strong&gt;wmake&lt;/strong&gt;, which is a wrapper around make for OpenFOAM. This is given a label &lt;em&gt;*wmake-build **which is referenced in the “preLaunchTask” field in *launch.json&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;“program” specifies where to deposit the binary from the executable. As discussed, this should be in &lt;strong&gt;$FOAM_USER_APPBIN.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The final .json file, &lt;em&gt;c_cpp_properties.json&lt;/em&gt;, contains the include paths for the compiler, as well as the settings for Intellisense.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*OgX1Oz6TLtc5vF_Wwrv-pw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Edit the Make/files to make sure your binary ends up in the right place after wmake.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*8WSHlW8QLAz48vPortUHHA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This process is very similar for compiling your own libraries. You will have to write in &lt;em&gt;*wmake libso **in the *tasks.json&lt;/em&gt; file instead to compile all the .so files.&lt;/p&gt;

&lt;p&gt;And voila, you can compile OpenFOAM code! Complete with code completion and references to other code blocks — this allows for a seamless start into the freedom OpenFOAM development brings with it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2732/1*reDyQdIu4_p2RvhvQt64ag.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>Mustafa Bhotvawala</name></author><summary type="html">Well, if you’re this far, you’re no stranger to open source fluid simulation software. Or you’ve finally broken free from the binds that commercial CFD software pose — “I’m just going to do it myself”, you say all too confidently as you jostle out of your fifteenth meeting with your software support that month.</summary></entry></feed>